<html>
  <head>
    <title>Sam Heslop</title>
    <meta charset="utf-8">
    <link rel="shortcut icon" type="image/jpeg" href="../favicon.ico"/>
    <link rel="stylesheet" type="text/css" href="../style.css">
    <link href="https://fonts.googleapis.com/css?family=Oxygen" rel="stylesheet">
  </head>
  <body>
    <div>
      <p><a href="https://samheslop.com" class="me">Sam Heslop</a><p>
    </div>
    <div id="md">
      <h1 id="understandingnoncereusevulnerabilitiespt2nonces">Understanding Nonce Reuse Vulnerabilities Pt.2: Nonces</h1>
<p>Continuing on from <a href="https://samheslop.com/posts/20181208_understanding_nonce_reuse_vulnerabilities_pt1_xor.html">part 1</a> where I took a quick overview of XOR operations in symmetric encryption algorithms, I next wanted to conduct a similar overview of nonces, their role, and more importantly, why their reuse can be render otherwise secure algorithms vulnerable.</p>
<h2 id="nonceakaivakainitialisationvectorakanumberusedonlyonce">Nonce aka ‘IV’ aka ‘initialisation vector’ aka ‘number used only once’</h2>
<p>Nonces are the vital element that ensures a single plaintext, encrypted twice with the same key, does not produce the same output. The term nonce more generally refers to a ‘number used only once’, meaning that a second encryption operation should use a different nonce, which, in some way, manipulates the encryption operation and therefore produce a different ciphertext. Often, they are constructed via PRNG, using the same method that is used for the encryption key, but there are also implementations that use incrementing integer or sequence counters as nonces; incrementing values reduces the chance of a duplicate nonce being generated via PRNG.</p>
<p>There is some flexibility around the terms nonce and initialisation vector/IV. Most authors tend to use only one or the other, but often their definition is interchangeable (IV tends to be used more when talking specifically about block ciphers). The term can be applied more broadly to equate to session keys, salts, uuids etc as well, but here I’m speaking specifically in the context of symmetric encryption algorithms.</p>
<p>A primary differentiator between a nonce and a key is that a nonce does not necessarily need to be considered secret; exposing the value of the nonce should not reduce the overall security of the protocol. Both parties need the value to encrypt/decrypt a message, but access to only the nonce or nonce+ciphertext/plaintext should not expose any information about the key.</p>
<h2 id="butwhatdoesanonceactuallydo">But what does a nonce actually <em>do</em>?</h2>
<p>To understand this, we need to think back to the construction of block ciphers; that the output of the previous block is used as the input to the subsequent block. That leaves the question though of how do we seed our initial block? If we don’t seed our initial block with some unique or random information, and simply begin by computing our first block against only our key, any messages that begin in an predictable manner (such as communication protocols that use headers or file types with predictable metadata headers), will encrypt in the same manner. If this predictable segment equals or extends the length of the first block, that information will be visible in the resulting ciphertext.</p>
<p>We can see this by sharing a key and nonce between two almost identical blocks of plaintext.</p>
<pre><code>a := []byte(`abcdefghijklmnopqrstuvwxyz123456`)
b := []byte(`abcdefghijklmnopqrstuvwxyz123457`)

key := make([]byte, 32)
nonce := make([]byte, 32)
rand.Read(key)
rand.Read(nonce)

c, _ := aes.NewCipher(key)
gcm, _ := cipher.NewGCMWithNonceSize(c, 32)

// Same nonce, same key and plaintext of block length with only 1 differing value = very similar ciphertexts
aOut := gcm.Seal(nil, nonce, a, nil) // A21E6938587978975B70D4CD2E9775E95EED47F8EB831C2145A37B74049A6FAFE6F0146CDF981691671AE1E4CB993C43
bOut := gcm.Seal(nil, nonce, b, nil) // A21E6938587978975B70D4CD2E9775E95EED47F8EB831C2145A37B74049A6FAE00B0E8EA155449DE2438A06075CD3CC2

bNonce := make([]byte, 32)
rand.Read(bNonce)

bWithNewNonce := gcm.Seal(nil, bNonce, b, nil) // F85737382B2D0DF1B59198F06F26D63D521EDD3D65552E6573AAE50585064F7FE9634B23848DC1EB98E6F86E72C3B1AE
</code></pre>
<p>This helps illustrates just how much influence the nonce has over the first block of our block cipher. Furthermore, since subsequent blocks are seeding with the result of the previous block, this influence extends to all blocks throughout the cipher, propagating massive changes through to the resulting ciphertext.</p>
<p>Randomly generated nonces, of equal length to the block length, are used to seed this initial block, which is why they are more often referred to as ‘initialisation vectors’ in the context of block ciphers. Using a different nonce/initialisation vector for each operations means the encryption of the first block begins from a different point, so all subsequent substitutions/permutations/transpositions etc produce different results. </p>
<h2 id="wrappingup">Wrapping Up</h2>
<p>Nonces guarantee the same plaintext produces different ciphertexts between different encryption operations. They do so by seeding the initial block of a block cipher, causing all subsequent blocks to produce different outputs as well, constituting the <a href="https://en.wikipedia.org/wiki/Confusion_and_diffusion#Definition">diffusion</a> component of a secure block cipher.</p>
<p>So now I’ve written briefly on some of the background to these nonce-reuse vulnerabilities, I feel a bit more confident to focus solely on how they might look in the wild, at how an attacker could exploit a vulnerable algorithm, and what information they could learn from doing so. Time for a part 3!</p>
    </div>
    <script src="../highlight.pack.js"></script>
    <script>
    window.onload = function(){var aCodes=document.getElementsByTagName('pre');for(var i=0;i<aCodes.length;i++) {hljs.highlightBlock(aCodes[i]);}};
    </script>
  </body>
</html>