<html>
  <head>
    <title>Sam Heslop</title>
    <meta charset="utf-8">
    <link rel="shortcut icon" type="image/jpeg" href="../favicon.ico"/>
    <link rel="stylesheet" type="text/css" href="../style.css">
  </head>
  <body>
    <div>
      <p><a href="https://samheslop.com" class="me">Sam Heslop</a><p>
    </div>
    <div id="md">
      <h1 id="terraformproviderimagesync">terraform-provider-imagesync</h1>
<p>Whenever I make infrastructure or configuration changes by hand, I often feel a slight twinge of shame, the shame that I didn't bother to automate the task, that I instead relied on my grubby, accident-prone human-hands rather than the infallibility of silicon and code. I felt this recently working with a private container registry that was being used for a k8s cluster that had no outbound network connection, and was instead pulling images from a private gcr.io registry via <a href="https://cloud.google.com/vpc/docs/private-access-options">Google Private Access</a>. This meant upgrading Prometheus or running some new deployment in the cluster would require the correct image to be made available in this private registry. Copying images from one registry to another is easy, some variation of <code>docker pull, tag, push ...</code> will get the job done, or you could use <a href="https://github.com/containers/skopeo">a cli tool like Skopeo</a>. Running these jobs could even be automated, if you share my distrust of manual processes, but defining and running some cron/pipeline job on a one-off basis seemed inelegant, and only solves half the problem; a true Infrastructure-as-Code solution would allow you to see the entire state of the registry, with all images and tags clearly defined and Git history describing exactly how and when those changes came to be.</p>
<p>To the best of my knowledge, there wasn't a Terraform provider that solved this problem, and I did really want the solution to be in Terraform, because ~~I'm obsessed~~ that would enable the assets that need to use these images to reference their tags through Terraform variables. So I decided to make my own. Like with most tooling I develop, I started by trying to determine the API that would best represent this problem space.</p>
<pre><code class="hcl language-hcl">resource "imagesync" "busybox_1_32" {
  source      = "registry.hub.docker.com/library/busybox:1.32"
  destination = "gcr.io/my-private-registry/busybox:1.32"
}
</code></pre>
<p>The idea with the API being that we can see, at a glance, both the image we sourced, and where we want the image to be copied into. This resource doesn't look very typical though. Terraform resources typically map very strictly to tangible 'assets' for which the CRUD operations can all be applied. Here, we're proposing an API that actually references 2 resources. The <code>destination</code>, does map <em>fairly</em> well to a CRUD resource, in that we can create, read and delete it (updates aren't really applicable, changing any element of the image is really just another image). The <code>source</code> however, is only ever read. This makes the logic and state management a little different.</p>
<h3 id="managingthedestinationstatereferencingthesourcestate">Managing the Destination State, Referencing the Source State</h3>
<p>Our goal here is to read the <code>source</code> image, and ensure that there is an image at the <code>destination</code> with that digest. Digests here are key, because your production systems <em>should always</em> be referencing digests and not tags where possible; a rogue actor could switch the underlying image for a particular tag, and you'd pull it all the same if your not checking the digest. So the logic of our operator needs to be to <em>always</em> read the <code>source</code> image, even if the <code>destination</code> exists, so we can check for a digest change. In-fact, if either the <code>source</code> or <code>destination</code> digests change from what we have in state, or the <code>destination</code> simply doesn't exist, we want to do a full tear-down and recreate (managed in Terraform by the <code>force_new</code> <a href="https://github.com/sHesl/terraform-provider-imagesync/blob/master/imagesync/resource_imagesync.go#L37">attribute</a>). This means a little more 'reading' required that a typical CRUD resource, but gives us the ability to spot digest changes in our plans.</p>
<p>As I mentioned before, I think it is important to use digests everywhere possible, so the provider should allow us to reference these digests when we are referencing these images in other resources.</p>
<pre><code class="hcl language-hcl">resource "kubernetes_deployment" "hi_busybox" {
  spec {
    ... 
    template {
      ...
      spec {
        container {
          name  = "hi-busybox"
          image = imagesync.busybox_1_32.id // gcr.io/my-private-registry/busybox@sha256:xxx
        }
      }
    }
  }
}
</code></pre>
<h3 id="writingaterraformprovider">Writing a Terraform provider</h3>
<p>I'd never seen a single project that managed to build a robust plugin architecture, at least until I played around with Terraform providers. The <code>github.com/hashicorp/terraform/helper/schema</code> and <code>github.com/hashicorp/terraform/terraform</code> libraries are straightforward to use, and the development lifecycle of running something like <code>go build . -o terraform-provider-imagesync_v0.0.1 &amp;&amp; mv terraform-provider-imagesync_v0.0.1 ~/.terraform.d/plugins/$your_local_registry_name/imagesync/0.0.1/darwin_amd64/</code> would compile the provider and make it available in your local registry so you can load it like so:</p>
<pre><code class="hcl language-hcl">terraform {
  required_version = "&gt;= 0.13.1"

  required_providers {
    imagesync = {
      source = "registry.github.com.local/sHesl/imagesync"
      version = "0.0.2"
    }
  }
}
</code></pre>
<p>A lot of this stuff (like the logical registry path) changed in 0.13, so I can't comment on the old approach, but this gave me a nice quick turnaround for testing changes. Speaking of testing, unit testing a provider with the test harness Hashicorp have developed was great; including testing the deletion of resources by default was a great inclusion for ensuring developers are considering the full lifecycle of their resources.</p>
<p>Pushing to the Hashicorp registry was even easier, <a href="https://github.com/sHesl/terraform-provider-imagesync/blob/master/.github/workflows/release.yml">following their Github Actions template</a> to get releases signed and published into the registry. Not having to set up some convoluted build step to retrieve my custom provider made integrating this into our existing Terraform setups <em>so</em> much easier.</p>
<h3 id="wrapup">Wrap-up</h3>
<p>Now I've got an automated way for ensuring those mission-critical images are kept in lock-step with the infrastructure that uses them, safe in the knowledge I'm keeping track of digest changes and have older releases being cleaned up automatically. I've even taken to adding these <code>id</code> references into our <a href="https://cloud.google.com/binary-authorization">Binary Authorization</a> policies, to ensure only images present in our Terraform configuration for BA can be deployed into our clusters.</p>
<p>Next time I'm pining for an automated solution for a problem, I'll definitely consider writing a new Terraform provider as a strong contender, plus it was fun! It's nice to write some code every-once in a while :)</p>
    </div>
    <script src="../highlight.pack.js"></script>
    <script>
    window.onload = function(){var aCodes=document.getElementsByTagName('pre');for(var i=0;i<aCodes.length;i++) {hljs.highlightBlock(aCodes[i]);}};
    </script>
  </body>
</html>